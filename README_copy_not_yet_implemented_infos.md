The Backend Container supports hot reloading, which means that editing files and saving changes will be reflected instantly. For the Debug Version, the current handler must be finished, then the worker will restart after saving the changes. The Container is a bit delayed but the logs show if and when it happend

<!-- ## Environments
The backend currently supports the environment ```--env <environment>``` which will be interpreted as follows:
- django settings file ```main.settings.<environment>.py``` will be used
- .env.\<environment> will be used for the environment variables
- if the environment MODE=\<environment> is set, in asgi application it will work as on ```python manage.py command --env <environment>``` has been set (used for backend docker container) -->


## Installation for dev purposes
- check, that you have at least Python 3.11 installed (via Terminal/Powershell and `python --version`) and correctly linked in your system environment variables (see: https://realpython.com/add-python-to-path/)
- clone the repository via SSH (in VS Code preferably)
- run ```git submodule init``` to initialize your local configuration file, and 
- run ```git submodule update``` to fetch all the data from that project and check out the appropriate commit listed in your superproject.
- for a clean initialization, check that the `postgres` as well as the `redis` folder is empty (if they already exist, if not they should be generated by the containers)
- call ```python -m pip install -r requirements.txt``` to install packages to your local machine (optional)
- to run the backend, you need at least one ".env" file, either you ask your team to send it to you, or generate them yourself. To do the latter, use the exampleEnv.txt as template and fill in the blancs. Then do the following:
  - Name the file `.env.local_container`
  - copy `.env.local_container` and name the new file `.env.local` and change internal connections hosts (e.g. database, redis) to localhost as well as ENV_TOKEN to local to see which env file is being used in outputs
  - repeat this step for `.env.production` and `.env.staging` 
- create the folder `logs` if it doesn't exist in the root directory of the project, as well as the files `info.log`, `performance.log` and `ip_log.log` inside it. Open your WSL/Terminal and call `sudo chown -R 5678 logs/` to give the docker container the rights to edit them
- LOCAL ONLY: call ```start_local_dev.bat -m local ``` to build and run only the containers with background connections (database, redis, ...) (Hint: on Windows use the .bat version on Linux the .sh version)
- LOCAL ONLY: call ```python manage.py create_db --env local``` to create the database named in `.env.local` (which should be the same as in `.env.local_container`) 
- OR CONTAINER ONLY: launch the containerized version twice (first will create the db, second will use it)
- LOCAL ONLY: call ```python manage.py migrate --env local``` to migrate the database to the latest state 
- LOCAL ONLY: now you can call ```python manage.py runserver --env local``` to start the backend locally and edit 
- OR CONTAINER ONLY: or you can run all in a container (including the backend) with ```start_local_dev.bat -m local_container``` 
- OR DEBUG ONLY: use VS Code and RUN->Start Debugging but beforehand, stop all containers with ```stop_local_dev.bat```

INFO: Whenever you call `manage.py`, add `--env .env.[MODE]` to it

<!-- INFO: you can watch exposed ports of the docker containers for connections i.e. pg-admin -->




<!-- ## Debug logging
In order to have debug output in the console, in your .env.[MODE] file set ```DJANGO_LOG_LEVEL=DEBUG```.
To log your messages use ```getLogger("django_debug").debug("your message")``` -->


## Optional commands
- ```python manage.py generate_env``` to output an example env file with default values, use with "-p --env <environment>" to get see the values currently used in django
- ```python manage.py create_db --env <environment>``` to create the database named in <environment> - which for now should be "local"
- ```python manage.py check --env <environment>``` to check if the parameters are set, the database can be reached, redis can be reached
- ```python manage.py mail --env <environment> email-address``` to send a test mail to the email-address