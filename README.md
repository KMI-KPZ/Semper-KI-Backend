# Backend for SEMPER-KI

## Branch descriptions:
- **dev**: Where all branches derive from and will be pushed to
- **staging**: Intermediate between dev and production to test stuff in a live environment before pushing it to main, has CI and CD
- **main**: production branch, only pull requests from staging go here, has CI and CD

<!-- ## Environments
The backend currently supports the environment ```--env <environment>``` which will be interpreted as follows:
- django settings file ```main.settings.<environment>.py``` will be used
- .env.\<environment> will be used for the environment variables
- if the environment MODE=\<environment> is set, in asgi application it will work as on ```python manage.py command --env <environment>``` has been set (used for backend docker container) -->

## Good to know
- The Backend Container supports hot reloading, which means that editing files and saving changes will be reflected instantly. For the Debug Version, the current handler must be finished, then the worker will restart after saving the changes. The Container is a bit delayed but the logs show if and when it happend
- The documentation can be seen via the `http://127.0.0.1:8000/private/doc` path, should the backend function correctly
- The backend uses Swagger UI for its API Paths, when the backend is running locally, call `http://127.0.0.1:8000/public/api/schema/swagger-ui/`
- There is a `.pylintrc` file in the main folder which can be used for the VS Code extension "Pylint"

## Installation for dev purposes
- check, that you have at least Python 3.11 installed (via Terminal/Powershell and `python --version`) and correctly linked in your system environment variables (see: https://realpython.com/add-python-to-path/)
- clone the repository via SSH (in VS Code preferably)
- run ```git submodule init``` to initialize your local configuration file, and 
- run ```git submodule update``` to fetch all the data from that project and check out the appropriate commit listed in your superproject.
- for a clean initialization, check that the `postgres` as well as the `redis` folder is empty (if they already exist, if not they should be generated by the containers)
- call ```python -m pip install -r requirements.txt``` to install packages to your local machine (optional)
- to run the backend, you need at least one ".env" file, either you ask your team to send it to you, or generate them yourself. To do the latter, use the exampleEnv.txt as template and fill in the blancs. Then do the following:
  - Name the file `.env.local_container`
  - copy `.env.local_container` and name the new file `.env.local` and change internal connections hosts (e.g. database, redis) to localhost as well as ENV_TOKEN to local to see which env file is being used in outputs
  - repeat this step for `.env.production` and `.env.staging` 
- create the folder `logs` if it doesn't exist in the root directory of the project, as well as the files `info.log`, `performance.log` and `ip_log.log` inside it. Open your WSL/Terminal and call `sudo chown -R 5678 logs/` to give the docker container the rights to edit them
- LOCAL ONLY: call ```start_local_dev.bat -m local ``` to build and run only the containers with background connections (database, redis, ...) (Hint: on Windows use the .bat version on Linux the .sh version)
- LOCAL ONLY: call ```python manage.py create_db --env local``` to create the database named in `.env.local` (which should be the same as in `.env.local_container`) 
- OR CONTAINER ONLY: launch the containerized version twice (first will create the db, second will use it)
- LOCAL ONLY: call ```python manage.py migrate --env local``` to migrate the database to the latest state 
- LOCAL ONLY: now you can call ```python manage.py runserver --env local``` to start the backend locally and edit 
- OR CONTAINER ONLY: or you can run all in a container (including the backend) with ```start_local_dev.bat -m local_container``` 
- OR DEBUG ONLY: use VS Code and RUN->Start Debugging but beforehand, stop all containers with ```stop_local_dev.bat```

INFO: Whenever you call `manage.py`, add `--env .env.[MODE]` to it

<!-- INFO: you can watch exposed ports of the docker containers for connections i.e. pg-admin -->

## Folder structure
- `.`: The main folder contains the manage.py file of django and docker files as well as the .env files
  - `.devcontainer`: Contains the json needed for running the service containers together with the debug container
  - `.github`: Contains the CI workflow used in GitHub Actions
  - `.vscode`: Everything necessary to run the debug-mode of VS Code
  - `Benchy`: A small tool to fire calls to certain paths
  - `code_SemperKI`: The main part of the software
    - `connections`: All connections to external and internal services like postgres, openai and such
      - `content`: The session interface
        - `postgresql`: The postgres interface
    - `handlers`: All API Paths that are specific to Semper-KI but not to the individual services it offers, only the API interface, no logics
      - `private`: API Paths only callable from the local environment
      - `public`: API Paths callable from outside (e.g. by the Frontend)
    - `logics`: The corresponding logics of the handlers
    - `migrations`: Django database migration versions
    - `modelFiles`: Database interfaces and models
    - `services`: All services that this platform offers, as a representative, see here the service "Additive Manufacturing"
      - `service_AdditiveManufacturing`: General stuff that every service has to provide
        - `connections`: Same as in Semper-KI but now for this service in particular
          - `postgresql`: Since this service has their own models, it needs a connection to the db
        - `handlers`: API Paths of this service
          - `public`: Only public paths available
            - `resources`: Paths specific to the resource page of the platform
        - `logics`: Logics of the handlers
        - `modelFiles`: Models of the service
        - `tasks`: Tasks that can be run in the background
        - `utilities`: Helper functions
    - `settings`: Django settings for this app
    - `SPARQLQueries`: Old folder that could have hold all relevant SPARQL queries
      - `Coypu`: Queries specific to the Coypu service (deprecated)
    - `states`: The statemachine of Semper-KI
    - `tasks`: Background tasks
    - `templates`: HTML Templates
    - `utilities`: Helper functions
  - `doc`: Documentation of the Backend
  - `docker`: Docker scripts for redis and minio
  - `Generic_Backend`: The generic backend, included here as a submodule
    - `code_General`: Main folder with source code
      - `.vscode`: Debug stuff, not used here
      - `configs`: Contains the auth0 configuration
      - `connections`: DB connections and such
        - `postgresql`: postgres connection
      - `handlers`: API Paths for generic purposes
      - `logics`: Logics of the paths
      - `migrations`: Migrations of django
      - `modelFiles`: Model files of the GB
      - `settings`: Settings, not used here
      - `templates`: HTML Templates
      - `utilities`: Helper functions
  - `logs`: Logfiles
  - `main`: Main django app
    - `helper`: Helper stuff like checking connections
    - `management`: Local command line tools
      - `commands`: 
    - `settings`: Main settings of the Backend
  - `minio`: Folder containing the locally saved files
  - `MSQ`: Message queue for celery tasks
    - `handlers`: Handlers for the celery workers
    - `module`: Celery module
    - `tasks`: The tasks themselves
      - `scripts`: Scripts that can be run by the workers
  - `Ontology`: Ontology submodule, not used
  - `postgres`: Folder that holds the database
  - `redis`: Folder that holds snapshots of redis
  - `run`: Run scripts


<!-- ## Debug logging
In order to have debug output in the console, in your .env.[MODE] file set ```DJANGO_LOG_LEVEL=DEBUG```.
To log your messages use ```getLogger("django_debug").debug("your message")``` -->

## Docker files
There are a couple of docker and docker-compose files in the root folder. 
Regarding the docker files:
- `Dockerfile`: Used by local docker-compose files, uses caching for faster builds
- `Dockerfile.Server`:  Used for compose files that run on a server (no caching for example)

As for the compose files:
- `docker-local-dev-container-backend.yml`: For the backend container when running in local_container mode
- `docker-local-dev-services.yml`: Every other container like redis, postgres and so on for local use
- `docker-compose.test.yml`: For running the tests, can be called via docker-compose up directly, used by GitHub Actions
- `docker-compose.staging.yml`: Used on the server for staging
- `docker-compose.production.yml`: Same as above albeit for production

## Optional commands
- ```python manage.py generate_env``` to output an example env file with default values, use with "-p --env <environment>" to get see the values currently used in django
- ```python manage.py create_db --env <environment>``` to create the database named in <environment> - which for now should be "local"
- ```python manage.py check --env <environment>``` to check if the parameters are set, the database can be reached, redis can be reached
- ```python manage.py mail --env <environment> email-address``` to send a test mail to the email-address


